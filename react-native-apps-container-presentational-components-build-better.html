<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=description content="As a React or React Native developer, it is important to understand the concept of container and presentational components. These design patterns help with the proper separation of concerns. You can use this concept to ensure that you structure your code in a more maintainable and scalable way."><meta name=author content="Larita Shotwell"><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=robots content="index,follow,noarchive"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/base16/css/style.css type=text/css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type=text/css><link rel=alternate href=./index.xml type=application/rss+xml title=RaveBlog><title>Build Better React Native Apps With Container and Presentational Components - RaveBlog</title></head><body><header><div class="container clearfix"><a class=path href=./index.html>[RaveBlog]</a>
<span class=caret># _</span><div class=right></div></div></header><div class=container><main role=main class=article><article class=single itemscope itemtype=http://schema.org/BlogPosting><div class=meta><span class=key>published on</span>
<span class=val><time itemprop=datePublished datetime=2024-04-26>April 26, 2024</time></span>
<span class=key>in</span>
<span class=val><a href=./categories/blog>blog</a></span></div><h1 class=headline itemprop=headline>Build Better React Native Apps With Container and Presentational Components</h1><section class=body itemprop=articleBody><p>As a React or React Native developer, it is important to understand the concept of container and presentational components.</p><p>These design patterns help with the proper separation of concerns. You can use this concept to ensure that you structure your code in a more maintainable and scalable way.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h2 id=what-are-container-components>What Are Container Components?</h2><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.makeuseofimages.com/wordpress/wp-content/uploads/2023/01/smart-components.jpg><p>Container components, also known as smart components, are responsible for managing data and logic in your app. They handle tasks like fetching data from an API, updating state, and processing user interactions.</p><p>To implement this structure, you can use <a href=#>a library such as React-Redux</a> to connect your components to the store and pass data and actions down to your child components or presentational components.</p><h2 id=what-are-presentational-components>What Are Presentational Components?</h2><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.makeuseofimages.com/wordpress/wp-content/uploads/2023/01/dumb-components.jpg> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>Presentational components are responsible for displaying data from their parent components. They are often stateless and focus on the UI and the visual representation of the data.</p><p>This state makes them easy to manipulate and test, earning them the name of dumb components. The dumb state of presentational components makes it possible for you to reuse them across your whole application. This avoids lousy and repetitive code.</p><h2 id=why-use-container-and-presentational-components>Why Use Container and Presentational Components?</h2><p>The short and simple answer to the question is: Separation of Concerns. This is a key principle in several paradigms, including object-oriented, functional, and aspect-oriented programming. However, many React developers tend to ignore these concepts and opt to write code that just works.</p><p>Code that just works is great, until it stops working. Poorly organized code is harder to maintain and update. This can make it tricky to add new features or bring in other programmers to work on the project. Fixing these issues once already created is a workload, and they are better prevented from the onset.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong> <img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.makeuseofimages.com/wordpress/wp-content/uploads/2023/01/why-use-c-p-components.jpg><p>Applying the container and presentational components design pattern ensures that every component within your project has a clear task that it handles. This achieves a modular structure where each optimized component comes together to complete your app.</p><p>Your components may still overlap; the division of duties between a container and a presentational component is not always distinct. However, as a general rule, you should focus your presentational components on visual data, and your container components on data and logic.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h2 id=how-to-use-container-and-presentational-components-in-react-native>How to Use Container and Presentational Components in React Native</h2><p>In a typical React Native app, it is common to create components that contain both presentational and logic-related code. You might fetch data from an API, manage the state of a form, and display output all in one class. Consider a simple app that will <a href=#>fetch a list of users from an API</a> and display their names and age.</p><p>You can do this with a single component, but it will result in code that is difficult to read, not reusable, and harder to test and maintain.</p><p>For example:</p><pre><code class="hljs javascript"><span class=hljs-keyword>import</span> React, { useState, useEffect } <span class=hljs-keyword>from</span>&nbsp;<span class=hljs-string>'react'</span>;<br><span class=hljs-keyword>import</span> { View, Text, FlatList } <span class=hljs-keyword>from</span>&nbsp;<span class=hljs-string>'react-native'</span>;<p><span class=hljs-keyword>const</span> UserList = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {<br>&nbsp;&nbsp;<span class=hljs-keyword>const</span> [users, setUsers] = useState([]);</p><p>&nbsp;&nbsp;useEffect(<span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=hljs-keyword>const</span> fetchUsers = <span class=hljs-keyword>async</span> () =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=hljs-keyword>const</span> response = <span class=hljs-keyword>await</span> fetch(<span class=hljs-string>'https://example.com/users'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=hljs-keyword>const</span> data = <span class=hljs-keyword>await</span> response.json();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setUsers(data);<br>&nbsp;&nbsp;&nbsp;&nbsp;};</p><p>&nbsp;&nbsp;&nbsp;&nbsp;fetchUsers();<br>&nbsp;&nbsp;}, []);</p><p>&nbsp;&nbsp;<span class=hljs-keyword>return</span> (<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;FlatList<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data={users}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyExtractor={item =&gt; item.id}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;renderItem={({ item }) =&gt; (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;View&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Text&gt;Name: {item.name}&lt;<span class=hljs-regexp>/Text&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Text&gt;Age: {item.age}&lt;<span class=hljs-regexp>/Text&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span class=hljs-regexp>/View&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)}<br>&nbsp;&nbsp;&nbsp;&nbsp;/&gt;<br>&nbsp;&nbsp;);<br>};</p><p><span class=hljs-keyword>export</span>&nbsp;<span class=hljs-keyword>default</span> UserList;<br></p></code> </pre><p>In this example, <strong>UserList</strong> is responsible for managing the state of an input field, fetching data from an API, and rendering the data.</p><p>The better and more efficient way to implement this is to separate the logic in UserList into presentation and container components.</p><p>You can create a <strong>UserListContainer</strong> component that is responsible for fetching and managing the user data. It can then pass this data to a presentational component, <strong>UserList</strong>, as a prop.</p><pre><code class="hljs javascript"><span class=hljs-keyword>import</span> React, { useState, useEffect } <span class=hljs-keyword>from</span>&nbsp;<span class=hljs-string>'react'</span>;<p><span class=hljs-comment>// Container Component</span><br><span class=hljs-keyword>const</span> UserListContainer = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {<br>&nbsp;&nbsp;<span class=hljs-keyword>const</span> [users, setUsers] = useState([]);</p><p>&nbsp;&nbsp;useEffect(<span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=hljs-keyword>const</span> fetchUsers = <span class=hljs-keyword>async</span> () =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=hljs-keyword>const</span> response = <span class=hljs-keyword>await</span> fetch(<span class=hljs-string>'https://example.com/users'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=hljs-keyword>const</span> data = <span class=hljs-keyword>await</span> response.json();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setUsers(data);<br>&nbsp;&nbsp;&nbsp;&nbsp;};</p><p>&nbsp;&nbsp;&nbsp;&nbsp;fetchUsers();<br>&nbsp;&nbsp;}, []);</p><p>&nbsp;&nbsp;<span class=hljs-keyword>return</span>&nbsp;<span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>UserList</span>&nbsp;<span class=hljs-attr>users</span>=<span class=hljs-string>{users}</span> /&gt;</span></span>;<br>};</p><p><span class=hljs-keyword>export</span>&nbsp;<span class=hljs-keyword>default</span> UserListContainer;<br></p></code> </pre><p>You can separate the presentation between two presentational components: <strong>User</strong> and <strong>UserList</strong>. Each is responsible for simply generating markup based on input props they receive.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><pre><code class="hljs javascript"><span class=hljs-keyword>import</span> { View, Text, FlatList } <span class=hljs-keyword>from</span>&nbsp;<span class=hljs-string>'react-native'</span>;<p><span class=hljs-comment>// Presentational Component</span><br><span class=hljs-keyword>const</span> User = <span class=hljs-function>(<span class=hljs-params>{ name, age }</span>) =&gt;</span> (<br>&nbsp;&nbsp;&lt;View&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;Text&gt;Name: {name}&lt;<span class=hljs-regexp>/Text&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;Text&gt;Age: {age}&lt;<span class=hljs-regexp>/Text&gt;</span><br>&nbsp;&nbsp;&lt;<span class=hljs-regexp>/View&gt;</span><br>);</p><p><span class=hljs-comment>// Presentational Component</span><br><span class=hljs-keyword>const</span> UserList = <span class=hljs-function>(<span class=hljs-params>{ users }</span>) =&gt;</span> (<br>&nbsp;&nbsp;&lt;FlatList<br>&nbsp;&nbsp;&nbsp;&nbsp;data={users}<br>&nbsp;&nbsp;&nbsp;&nbsp;keyExtractor={item =&gt; item.id}<br>&nbsp;&nbsp;&nbsp;&nbsp;renderItem={({ item }) =&gt; <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>User</span>&nbsp;<span class=hljs-attr>name</span>=<span class=hljs-string>{item.name}</span>&nbsp;<span class=hljs-attr>age</span>=<span class=hljs-string>{item.age}</span> /&gt;</span></span>}<br>&nbsp;&nbsp;/&gt;<br>);<br></p></code> </pre><p>The new code separates the original component into two presentational components, <strong>User</strong> and <strong>UserList</strong>, and one container component, <strong>UserListContainer</strong>.</p><h2 id=best-practices-for-implementing-container-and-presentational-components>Best Practices for Implementing Container and Presentational Components</h2><p>When you use container and presentational components, it's important to follow some best practices to ensure that the components work as intended.</p><li>Each component should have a clear and specific role. The container component should manage state and the presentational component should handle visual presentation.</li><li>Where possible, use functional components instead of class components. They are simpler, easier to test, and provide better performance.</li><li>Avoid including logic or functionality in a component that is irrelevant to its purpose. This helps to keep components focused and easy to maintain and test.</li><li>Use props for communication between components, clearly separating concerns and avoiding tightly-coupled components.</li><li>Unnecessary updates to state can lead to performance issues, so it's important to only update state when necessary.</li><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>Following these best practices ensures that your container and presentational components work together effectively to provide a clean, organized, and scalable solution for managing state and visual presentation in your React Native app.</p><h2 id=the-benefits-of-using-container-and-presentational-components>The Benefits of Using Container and Presentational Components</h2><p>Container and Presentational Components can provide several benefits. They can help improve your code structure, maintainability, and scalability. They also result in better collaboration and delegation of tasks among teams. They can even lead to increased performance and optimization of your React Native app.</p><p>Follow best practices for implementing these components, and you can build better and more scalable React Native apps.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7rq3KnqysnZ%2Bbe6S7zGipnpmTqXqvrdOirZ5lkaW9tHnCqKWtmZmjsrN5z6ucrJ2eqa61tc6nmKVlk6S6sbvNnqWtq12Xwqq4w2aZnqykmr9w</p></section></article></main></div><footer><div class=container><span class=copyright>&copy; 2024 RaveBlog - <a rel=license href=http://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a></span></div></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>